# app/models/amigo.rb
require 'digest/md5'
require 'open-uri'

class Amigo < ApplicationRecord
  # === Associations ===
  has_one_attached :avatar
  has_one  :amigo_detail,    dependent: :destroy
  has_many :amigo_locations, dependent: :destroy
  has_many :lead_coordinator_for_events, class_name: 'Event', foreign_key: 'lead_coordinator_id'
  has_many :event_amigo_connectors
  has_many :events, through: :event_amigo_connectors

  # === Devise Modules ===
  # Using denylist strategy (JwtDenylist table). Do NOT include JTIMatcher.
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable,
         :lockable, :timeoutable, :confirmable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtDenylist

  # Virtual attribute used by Devise (see devise initializer)
  attr_accessor :login_attribute

  # === Avatar source constants ===
  # Columns (add via migration): avatar_source:string, avatar_remote_url:string, avatar_synced_at:datetime
  AVATAR_SOURCES = %w[upload gravatar url default].freeze

  # === Validations ===
  validates :first_name, :last_name,
            presence: true,
            length:   { maximum: 50 }

  validates :user_name,
            presence: true,
            uniqueness: { case_sensitive: false },
            length: { maximum: 50 },
            format: { with: /\A[a-zA-Z0-9_]+\z/ }

  validates :email,
            uniqueness: { case_sensitive: false },
            format: { with: URI::MailTo::EMAIL_REGEXP }

  validates :secondary_email,
            allow_blank: true,
            uniqueness: { case_sensitive: false },
            format: { with: URI::MailTo::EMAIL_REGEXP }

  validates :phone_1,
            uniqueness: true,
            allow_blank: true,
            format: { with: /\A\+\d{6,15}\z/ }

  validates :phone_2,
            uniqueness: true,
            allow_blank: true,
            format: { with: /\A\+\d{6,15}\z/ }

  validates :avatar,
            content_type: ['image/png', 'image/jpg', 'image/jpeg', 'image/svg+xml']

  # validate :at_least_one_identifier_present  # (optional custom rule)

  # === Callbacks ===
  before_validation :normalize_identifiers

  # Process uploaded/attached avatar to a normalized PNG once.
  after_commit :process_avatar, if: -> { avatar.attached? }, on: [:create, :update]

  # After create, if user has no avatar, try gravatar then fall back to default.
  after_commit :ensure_initial_avatar, on: :create

  # === Auth (Devise custom finder) ===
  def self.find_for_database_authentication(warden_conditions)
    raw = warden_conditions[:login_attribute].to_s.strip
    return nil if raw.blank?

    login_down = raw.downcase
    phone_norm = normalize_phone(raw) # E.164 or nil

    where(
      "LOWER(user_name) = :login OR LOWER(email) = :login OR phone_1 = :phone OR phone_2 = :phone",
      login: login_down, phone: phone_norm
    ).first
  end

  # === Roles / helpers ===
  def admin?
    role == 'admin' || is_admin
  end

  def lead_coordinator_for?(event)
    event_amigo_connectors.exists?(event_id: event.id, role: 'lead_coordinator')
  end

  def assistant_coordinator_for?(event)
    event_amigo_connectors.exists?(event_id: event.id, role: 'assistant_coordinator')
  end

  def can_remove_participant?(event)
    lead_coordinator_for?(event) || assistant_coordinator_for?(event)
  end

  def can_manage?(amigo)
    amigo && id == amigo.id
  end

  def event_roles
    event_amigo_connectors.includes(:event).map { |c| { event_id: c.event_id, role: c.role } }
  end

  # === Avatar URL (relative path for FE to prefix with API origin) ===
  def avatar_url
    if avatar.attached?
      Rails.application.routes.url_helpers.rails_blob_url(avatar, only_path: true)
    end
  end

  # Attach a pre-seeded avatar by identifier (used by your seeds/helpers)
  def attach_avatar_by_identifier(avatar_identifier)
    avatar_path = Rails.root.join('lib/seeds/avatars', "#{avatar_identifier}.svg")
    if File.exist?(avatar_path)
      avatar.attach(io: File.open(avatar_path), filename: "#{avatar_identifier}.svg", content_type: "image/svg+xml")
    else
      errors.add(:avatar, "specified avatar does not exist")
    end
  end

  # === Devise mailer ===
  def send_devise_notification(notification, *args)
    devise_mailer.send(notification, self, *args).deliver_later
  end

  # === JSON presentation ===
  def as_json(options = {})
    super(options).merge(
      phone_1: international_phone(phone_1),
      phone_2: international_phone(phone_2)
    )
  end

  # === Avatar source orchestration ===
  # Call this after changing avatar_source / avatar_remote_url (controller does that).
  def apply_avatar_preference!
    case avatar_source
    when 'upload'
      # File already attached in controller (multipart); just mark synced
      touch(:avatar_synced_at)
    when 'gravatar'
      if attach_gravatar
        touch(:avatar_synced_at)
      else
        attach_default_avatar
      end
    when 'url'
      if avatar_remote_url.present? && attach_remote_image(avatar_remote_url)
        touch(:avatar_synced_at)
      else
        errors.add(:avatar_remote_url, "is not fetchable as an image")
        return false
      end
    else # 'default' or nil
      attach_default_avatar
    end
    true
  end

  # Build a gravatar URL; use d=404 so we can detect â€œno imageâ€ via HTTP 404
  def gravatar_url(size: 200)
    return nil if email.blank?
    hash = Digest::MD5.hexdigest(email.strip.downcase)
    "https://www.gravatar.com/avatar/#{hash}?s=#{size}&d=404"
  end

  # Try to fetch/attach Gravatar (returns true if attached)
  def attach_gravatar
    url = gravatar_url(size: 200)
    return false if url.blank?
    attach_remote_image(url)
  end

  # Download an image from URL and attach to ActiveStorage
  def attach_remote_image(url)
    io = URI.open(url, "rb", read_timeout: 6, open_timeout: 6)
    content_type = io.content_type.to_s.downcase
    return false unless content_type.start_with?("image/")

    ext =
      if content_type.include?("png") then "png"
      elsif content_type.include?("jpeg") || content_type.include?("jpg") then "jpg"
      elsif content_type.include?("svg") then "svg"
      else "bin"
      end

    avatar.attach(io: io, filename: "remote_avatar.#{ext}", content_type: content_type)
    save! if changed?
    true
  rescue OpenURI::HTTPError
    false
  rescue => e
    Rails.logger.warn("attach_remote_image failed: #{e.class}: #{e.message}")
    false
  end

  # Attach default avatar blob if present and nothing attached
  def attach_default_avatar
    return if avatar.attached?
    default_blob = ActiveStorage::Blob.find_by(filename: 'default-amigo-avatar.svg')
    avatar.attach(default_blob) if default_blob
  end

  private

  # === Optional custom rule if you allow login without email/username ===
  def at_least_one_identifier_present
    if [user_name, email, phone_1, phone_2].all?(&:blank?)
      errors.add(:base, "Provide at least one of username, email, or phone.")
    end
  end

  def normalize_identifiers
    self.user_name = user_name&.strip
    self.email     = email&.strip&.downcase
    self.phone_1   = self.class.normalize_phone(phone_1)
    self.phone_2   = self.class.normalize_phone(phone_2)
  end

  def self.normalize_phone(value)
    return nil if value.blank?
    Phonelib.parse(value).e164.presence
  end

  def international_phone(phone)
    phone.present? ? Phonelib.parse(phone).international : nil
  end

  # Process any newly attached avatar once into a normalized PNG (~200x200)
  # Guards:
  #  - skip if metadata['processed'] is true
  #  - skip for non-image attachments (safety)
  def process_avatar
    blob = avatar.blob
    return unless blob&.content_type.to_s.start_with?('image/')
    return if blob.metadata.is_a?(Hash) && blob.metadata['processed'] == true

    # NOTE: resize_to_fill gives uniform square; change to resize_to_limit if you prefer
    processed_file = ImageProcessing::Vips
                      .source(avatar.download)
                      .resize_to_fill(200, 200)
                      .convert("png")
                      .call

    new_metadata = (blob.metadata || {}).merge('processed' => true)

    avatar.attach(
      io: File.open(processed_file.path),
      filename: "avatar.png",
      content_type: "image/png",
      metadata: new_metadata
    )

    touch(:avatar_synced_at)
  rescue => e
    Rails.logger.error "Avatar processing failed for Amigo ##{id}: #{e.message}"
  end

  # After create: if nothing attached, try gravatar; else default.
  def ensure_initial_avatar
    return if avatar.attached?
    self.avatar_source ||= 'gravatar'
    unless attach_gravatar
      self.avatar_source = 'default'
      attach_default_avatar
    end
    touch(:avatar_synced_at)
  end
end
