# Auth Snapshot (Tue Sep 23 20:09:20 PDT 2025)


---
## config/initializers/devise.rb

# config/initializers/devise.rb #

Devise.setup do |config|
  config.mailer_sender = 'tmichel@ssgacicweb.com'
  config.mailer = 'Devise::Mailer'
  config.parent_mailer = 'ActionMailer::Base'

  require 'devise/orm/active_record'

  config.authentication_keys   = [:login_attribute]
  config.case_insensitive_keys = [:login_attribute]
  config.strip_whitespace_keys = [:login_attribute]

  config.skip_session_storage = [:http_auth, :token_auth]

  config.stretches = Rails.env.test? ? 1 : 12 

  config.reconfirmable = true
  config.password_length = 10..64
  config.email_regexp = /\A[^@\s]+@[^@\s]+\z/
  config.reset_password_within = 6.hours
  config.timeout_in = 2.hours

  config.lock_strategy = :failed_attempts
  config.unlock_strategy = :time
  config.maximum_attempts = 5
  config.unlock_in = 15.minutes

  config.navigational_formats = []
  config.scoped_views = true
  config.sign_out_via = :delete

  # Optional (recommended in production)
  config.send_email_changed_notification = true
  config.send_password_change_notification = true

  config.jwt do |jwt|
    jwt.secret = Rails.application.credentials.dig(:devise, :jwt_secret_key)
    jwt.dispatch_requests = [['POST', %r{^/api/v1/login$}]]
    jwt.revocation_requests = [['DELETE', %r{^/api/v1/logout$}]]
    jwt.expiration_time = 2.hours.to_i
    jwt.request_formats = { amigo: [:json] }
  end

  config.pepper = Rails.application.credentials.dig(:devise, :pepper)

  config.warden do |manager|
    manager.failure_app = CustomFailureApp
  end
end


---
## config/initializers/cors.rb

# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin AJAX requests.

# Read more: https://github.com/cyu/rack-cors

# config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins 'https://localhost:5173'
    resource '*',
      headers: :any,
      methods: [:get, :post, :patch, :put, :delete, :options, :head],
      expose: ['Authorization', 'Set-Cookie', 'X-CSRF-Token'],
      credentials: true
  end
end


---
## config/initializers/rack_attack.rb

# config/initializers/rack_attack.rb
require 'rack/attack'

# Tiny in-memory store is fine in dev; use Redis in prod
Rack::Attack.cache.store = ActiveSupport::Cache::MemoryStore.new

# Don’t throttle CORS preflight or CSRF token fetch
Rack::Attack.safelist('allow-preflight-and-csrf') do |req|
  req.options? || req.path == '/api/v1/csrf'
end

# Throttle login attempts by IP
Rack::Attack.throttle('logins/ip', limit: 5, period: 20.seconds) do |req|
  req.ip if req.post? && req.path == '/api/v1/login'
end

# Throttle login attempts by credential (slow stuffing)
Rack::Attack.throttle('logins/login_attribute', limit: 5, period: 60.seconds) do |req|
  next unless req.post? && req.path == '/api/v1/login'
  begin
    raw = req.body.read
    data = JSON.parse(raw) rescue {}
    (data.dig('amigo', 'login_attribute') || '').downcase.presence
  ensure
    req.body.rewind
  end
end

# Throttle signups by IP
Rack::Attack.throttle('signups/ip', limit: 3, period: 10.minutes) do |req|
  req.ip if req.post? && req.path == '/api/v1/signup'
end

# NEW API: custom 429. Add CORS bits so the browser can read it.
Rack::Attack.throttled_responder = lambda do |request|
  match = request.env['rack.attack.match_data'] || {}
  retry_after = match[:period] || 60
  [
    429,
    {
      'Content-Type'                  => 'application/json',
      'Retry-After'                   => retry_after.to_s,
      'Access-Control-Allow-Origin'   => 'https://localhost:5173',
      'Access-Control-Allow-Credentials' => 'true'
    },
    [ { error: 'Too many requests' }.to_json ]
  ]
end


---
## config/initializers/warden.rb

# config/initializers/warden.rb

Rails.application.reloader.to_prepare do
  begin
    # Ensure the Amigo model and revocation strategy are loaded
    require_dependency 'amigo'
    require_dependency 'jwt_denylist'

    Warden::JWTAuth.configure do |config|
      config.secret = Rails.application.credentials.dig(:devise_jwt_secret_key)

      if config.secret.blank?
        Rails.logger.warn "Warden JWT setup: Missing Devise JWT secret key in credentials!"
      end

      config.dispatch_requests = [
        ['POST', %r{^/api/v1/login$}],
        ['DELETE', %r{^/api/v1/logout$}]
      ]

      config.revocation_requests = [
        ['DELETE', %r{^/api/v1/logout$}]
      ]

      config.mappings = { amigo: Amigo }
      config.revocation_strategies = { amigo: JwtDenylist }
    end
  rescue => e
    Rails.logger.error "Warden JWTAuth configuration failed: #{e.message}"
    raise
  end
end


---
## config/initializers/jwt.rb

# config/initializers/jwt.rb
#
# Make sure the JWT secret is present in credentials.
secret = Rails.application.credentials.dig(:devise, :jwt_secret_key)
if secret.blank?
  raise "JWT secret key is not set in credentials. Add devise.jwt_secret_key to config/credentials/*.yml.enc"
end

Rails.logger.info "[JWT] Loaded secret key successfully."


---
## config/initializers/session_store.rb

# config/initializers/session_store.rb

Rails.application.config.session_store :cookie_store,
  key: '_amigos_unite_session',
  same_site: :none,
  secure: true


---
## app/controllers/application_controller.rb

# app/controllers/application_controller.rb
class ApplicationController < ActionController::API
  include RackSessionsFix
  include Devise::Controllers::Helpers
  include ActionController::Cookies
  include ActionController::RequestForgeryProtection
  include Authentication
  include ActionController::Cookies

  before_action :promote_jwt_cookie_to_authorization

  prepend_before_action :force_devise_amigo_mapping

  # CSRF:
  # - Use Rails' CSRF for non-API (HTML) requests
  protect_from_forgery with: :exception, unless: -> { api_request? }

  # - For API GETs, issue a CSRF cookie the SPA can echo back
  before_action :set_csrf_cookie, if: -> { api_request? && request.get? }

  # - For API mutating requests, enforce CSRF header
  before_action :verify_csrf_token,
                if: -> { api_request? && request.method.in?(%w[POST PUT PATCH DELETE]) }

  # Auth everywhere except the public auth endpoints
  before_action :authenticate_amigo!, unless: :auth_public_endpoint?
  helper_method :current_amigo
  respond_to :json

  before_action :configure_permitted_parameters, if: :devise_controller?
  before_action :log_request

  # Optional: surface stack traces in dev logs for any uncaught 500
  rescue_from StandardError do |e|
    # Keep noisy in development; consider narrowing in production
    Rails.logger.error("Unhandled error: #{e.class}: #{e.message}\n#{e.backtrace&.first(10)&.join("\n")}")
    render json: { error: 'Internal Server Error' }, status: :internal_server_error
  end if Rails.env.development?

  # --- CSRF helpers ----------------------------------------------------------
  def set_csrf_cookie
    cookies['CSRF-TOKEN'] = {
      value:     form_authenticity_token,
      same_site: :none,
      secure:    true,
      http_only: false,
      path:      '/'
    }
  end

  def verify_csrf_token
    header = request.headers['X-CSRF-Token']
    unless header.present? && valid_authenticity_token?(session, header)
      Rails.logger.error "CSRF token mismatch. Received: #{header.inspect}"
      render json: { error: 'Invalid CSRF token' }, status: :unauthorized
    end
  end

  # For API requests, respond JSON instead of redirect when unauthenticated
  def authenticate_amigo!
    return super if amigo_signed_in?
    render json: { error: 'Unauthorized' }, status: :unauthorized
  end

  # --- Devise strong params --------------------------------------------------
  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_in, keys: %i[user_name email unformatted_phone_1 password])

    devise_parameter_sanitizer.permit(:sign_up, keys: %i[
      first_name last_name user_name email secondary_email
      unformatted_phone_1 unformatted_phone_2 avatar password password_confirmation
    ])

    devise_parameter_sanitizer.permit(:account_update, keys: %i[
      first_name last_name user_name email secondary_email
      unformatted_phone_1 unformatted_phone_2 avatar password current_password
    ])
  end

  private

  # Keep Devise mapping aligned on API auth endpoints
  def force_devise_amigo_mapping
    if request.path.start_with?("/api/v1/") &&
       %w[signup login refresh_token logout verify_token].any? { |seg| request.path.include?(seg) }
      Rails.logger.info "[APPLICATION] forcing Devise.mapping[:amigo] for #{request.path}"
      request.env["devise.mapping"] = Devise.mappings[:amigo]
    end
  end

  def auth_public_endpoint?
    path = request.path
    path.start_with?(
      '/api/v1/csrf',
      '/api/v1/signup',
      '/api/v1/login',
      '/api/v1/refresh_token',
      '/api/v1/verify_token',
      '/api/v1/logout'
    )
  end

  def promote_jwt_cookie_to_authorization
    cookie_token = cookies.signed[:jwt]
    header_token = request.headers['Authorization']

    # Prefer a good cookie over a missing/stale header
    if cookie_token.present? && (header_token.blank? || !header_token.start_with?('Bearer '))
      request.headers['Authorization'] = "Bearer #{cookie_token}"
    end
  rescue => e
    Rails.logger.warn "promote_jwt_cookie_to_authorization failed: #{e.class}: #{e.message}"
  end

  def api_request?
    request.format.json? || request.path.start_with?('/api')
  end

  def log_request
    Rails.logger.info "API Request to #{request.path} with headers: #{filtered_headers}"
  end

  def filtered_headers
    request.headers.to_h.except(
      *%w[
        rack.input action_dispatch.secret_key_base
        action_dispatch.signed_cookie_salt action_dispatch.encrypted_cookie_salt
        action_dispatch.encrypted_signed_cookie_salt action_dispatch.authenticated_encrypted_cookie_salt
        action_dispatch.http_auth_salt action_dispatch.secret_token
        action_dispatch.cookies_serializer action_dispatch.encrypted_cookie_cipher
        action_dispatch.signed_cookie_cipher action_dispatch.content_security_policy
        action_dispatch.content_security_policy_nonce_directives
        action_dispatch.content_security_policy_report_only
      ]
    )
  end

  # ───────────────────────────────────────────────────────────────────────────
  # Default avatar helper (NOT used during GET; only if you explicitly call it)
  # ───────────────────────────────────────────────────────────────────────────
  def attach_default_avatar(amigo, key: 'default-amigo-avatar')
    DefaultAvatars.sync! if DefaultAvatars.all.empty?
    if (blob = DefaultAvatars.find_by_key(key) || DefaultAvatars.random)
      amigo.avatar.attach(blob)
    else
      Rails.logger.warn "[DefaultAvatar] No blob found for key=#{key.inspect}"
    end
  end
end


---
## app/controllers/api/v1/auth/sessions_controller.rb

module Api
  module V1
    module Auth
      class SessionsController < Devise::SessionsController
        # Make sure Devise uses the :amigo mapping
        prepend_before_action -> { request.env['devise.mapping'] = Devise.mappings[:amigo] }
        before_action :ensure_devise_mapping, only: %i[create refresh verify_token]

        include ActionController::MimeResponds
        include ActionController::Cookies
        include ActionController::RequestForgeryProtection

        # We want JSON, not HTML exceptions
        respond_to :json

        skip_before_action :verify_signed_out_user, only: :destroy
        # Do NOT require auth for these endpoints
        skip_before_action :authenticate_amigo!, raise: false
        # CSRF should NOT block API auth endpoints

        skip_before_action :verify_authenticity_token,
          only: %i[create refresh destroy verify_token],
          raise: false


        before_action :ensure_devise_mapping,
          only: %i[create refresh verify_token destroy]

        # Force JSON format
        before_action :set_default_format

        # Catch any uncaught exceptions in this controller and render JSON (prevents HTML error pages)
        rescue_from StandardError do |e|
          Rails.logger.error "Unhandled error in SessionsController##{action_name}: #{e.class}: #{e.message}\n#{Array(e.backtrace).first(5).join("\n")}"
          render json: { status: { code: 500, message: 'Internal Server Error' } }, status: :internal_server_error
        end

        # POST /api/v1/login
        def create
          amigo = authenticate_amigo(params[:amigo])
          return unless amigo

          # Sign a new JWT (12h) and set cookie
          expires_at = 2.hours.from_now
          token      = JsonWebToken.encode({ sub: amigo.id }, expires_at)
          set_jwt_cookie(token, expires_at)

          response.set_header('Authorization', "Bearer #{token}")

          # Also (re)issue CSRF token cookie
          cookies['CSRF-TOKEN'] = {
            value:     form_authenticity_token,
            same_site: Rails.env.development? ? :none : :strict,
            secure:    true,
            http_only: false,
            path:      '/'
          }

          amigo_attrs = {
            id:         amigo.id,
            user_name:  amigo.user_name,
            email:      amigo.email,
            first_name: amigo.first_name,
            last_name:  amigo.last_name
          }

          render json: {
            status: { code: 200, message: 'Logged in successfully.' },
            data:   {
              amigo:          amigo_attrs,
              jwt_expires_at: expires_at.utc.iso8601
            }
          }, status: :ok
        end

        # DELETE /api/v1/logout

        def destroy
          token = cookies.signed[:jwt] || bearer_token

          if token.present?
            begin
              payload = JWT.decode(
                token,
                Rails.application.credentials.dig(:devise, :jwt_secret_key),
                true,
                algorithm: JsonWebToken::ALGORITHM
              ).first
              JwtDenylist.revoke_jwt(payload, nil) # best-effort
            rescue JWT::DecodeError => e
              Rails.logger.warn "Logout: token decode failed: #{e.message}"
              # continue to clear cookies and respond 204
            end
          else
            Rails.logger.info "Logout called with no token; treating as already signed-out"
          end

          # Always clear cookies (httpOnly jwt must be cleared by the server)
          cookies.delete(:jwt,         path: '/', same_site: :none, secure: true)
          cookies.delete('CSRF-TOKEN', path: '/', same_site: :none, secure: true)

          head :no_content
        end


        # POST /api/v1/refresh_token
        def refresh
          token = cookies.signed[:jwt] || bearer_token
          return render_error('Token missing', :unauthorized) unless token

          begin
            # allow expired tokens here (signature still required)
            payload = JsonWebToken.decode_allow_expired(token)
            amigo   = Amigo.find(payload[:sub])

            expires_at = 2.hours.from_now
            new_token  = JsonWebToken.encode({ sub: amigo.id }, expires_at)
            set_jwt_cookie(new_token, expires_at)

            response.set_header('Authorization', "Bearer #{new_token}")

            # rotate CSRF token too
            cookies['CSRF-TOKEN'] = {
              value:     form_authenticity_token,
              same_site: Rails.env.development? ? :none : :strict,
              secure:    true,
              http_only: false,
              path:      '/'
            }

            render json: {
              status: { code: 200, message: 'Token refreshed successfully.' },
              data:   { jwt_expires_at: expires_at.utc.iso8601 }
            }, status: :ok
          rescue ActiveRecord::RecordNotFound
            render_error('Amigo not found', :unauthorized)
          rescue JWT::DecodeError => e
            Rails.logger.error "Refresh decode error: #{e.message}"
            render_error('Invalid token', :unauthorized)
          end
        end

        # GET /api/v1/verify_token
        def verify_token
          token = cookies.signed[:jwt] || bearer_token
          return render json: { valid: false, reason: 'Missing token' }, status: :unauthorized if token.blank?

          begin
            payload = JsonWebToken.decode(token)  # will raise on invalid/expired
            exp     = (payload[:exp] || payload['exp']).to_i
            return render json: { valid: false, reason: 'Missing exp' }, status: :unauthorized if exp.zero?

            exp_time = Time.at(exp).utc
            render json: { valid: true, expires_at: exp_time.iso8601 }, status: :ok
          rescue JWT::ExpiredSignature
            render json: { valid: false, reason: 'Token expired' }, status: :unauthorized
          rescue JWT::DecodeError => e
            render json: { valid: false, reason: e.message }, status: :unauthorized
          end
        end

        private

        def ensure_devise_mapping
          request.env['devise.mapping'] ||= Devise.mappings[:amigo]
        end

        def bearer_token
          request.headers['Authorization']&.split(' ')&.last
        end

        def set_default_format
          request.format = :json
        end

        def set_jwt_cookie(token, expires_at)
          cookies.signed[:jwt] = {
            value:     token,
            httponly:  true,
            secure:    true,          # required with SameSite=None
            same_site: :none,         # frontend is on a different origin
            path:      '/',
            expires:   expires_at
          }
          Rails.logger.info "JWT cookie set to expire at #{expires_at.utc.iso8601}"
        end


        # app/controllers/api/v1/auth/sessions_controller.rb
        def authenticate_amigo(amigo_params)
          unless amigo_params
            render_error('Missing login parameters', :bad_request)
            return nil
          end

          login    = amigo_params[:login_attribute].to_s.strip.downcase
          password = amigo_params[:password].to_s

          Rails.logger.info "[LOGIN] Attempt for '#{login}'"

          amigo = Amigo.where('LOWER(email) = :login OR LOWER(user_name) = :login', login: login).first

          if amigo.nil?
            Rails.logger.warn "[LOGIN] No account found for '#{login}'"
            render_error('Invalid login credentials', :unauthorized)
            return nil
          end

          unless amigo.valid_password?(password)
            Rails.logger.warn "[LOGIN] Password mismatch for id=#{amigo.id} (#{amigo.email}/#{amigo.user_name})"
            render_error('Invalid login credentials', :unauthorized)
            return nil
          end

          amigo
        end


        def render_error(message, status_code)
          render json: {
            status: { code: Rack::Utils::SYMBOL_TO_STATUS_CODE[status_code], message: message },
            errors: [message]
          }, status: status_code
        end
      end
    end
  end
end


---
## app/controllers/api/v1/amigos_controller.rb

# app/controllers/api/v1/amigos_controller.rb
module Api
  module V1
    class AmigosController < ApplicationController
      before_action :authenticate_amigo!
      before_action :verify_csrf_token, only: %i[create update destroy]
      before_action :set_amigo, only: %i[show update destroy]
      before_action :authorize_amigo!, only: %i[destroy]
      helper_method :current_amigo

      # GET /api/v1/amigos
      def index
        Rails.logger.info("amigos#index - signed_in?=#{amigo_signed_in?}")
        amigos = Amigo.with_attached_avatar.all
        render json: amigos.map { |a| amigo_payload(a) }, status: :ok
      end

      # GET /api/v1/amigos/:id
      def show
        render json: amigo_payload(@amigo), status: :ok
      end

      # POST /api/v1/amigos
      def create
        @amigo = Amigo.new(amigo_params.except(:avatar))

        if @amigo.save
          # If an avatar identifier was provided, attach it AFTER save.
          if params.dig(:amigo, :avatar).present?
            @amigo.attach_avatar_by_identifier(params[:amigo][:avatar])
          end
          render json: amigo_payload(@amigo), status: :created
        else
          render json: { errors: @amigo.errors.full_messages }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/amigos/:id
      def update
        if @amigo.update(amigo_params)
          render json: amigo_payload(@amigo), status: :ok
        else
          render json: { errors: @amigo.errors.full_messages }, status: :unprocessable_entity
        end
      end

      # DELETE /api/v1/amigos/:id
      def destroy
        if @amigo.destroy
          render json: { message: 'Amigo deleted successfully' }, status: :ok
        else
          render json: { errors: @amigo.errors.full_messages }, status: :unprocessable_entity
        end
      end

      # GET /api/v1/me
      def me
        render json: { amigo: amigo_payload(current_amigo) }, status: :ok
      end

      private

      def set_amigo
        @amigo = Amigo.find(params[:id])
      end

      def amigo_params
        params.require(:amigo).permit(
          :first_name, :last_name, :user_name, :email, :secondary_email,
          :unformatted_phone_1, :unformatted_phone_2, :password, :avatar
        )
      end

      # Consistent, defensive JSON for Amigos.
      def amigo_payload(amigo)
        # Choose fields to expose
        base = amigo.as_json(
          only: %i[id first_name last_name user_name email secondary_email phone_1 phone_2]
        )
        base.merge(avatar_url: safe_avatar_url_for(amigo))
      end

      # Never mutate state (attach defaults) during GETs.
      # Only produce a URL if an attachment and blob exist.
      def safe_avatar_url_for(amigo)
        att = amigo.avatar
        return nil unless att&.attached? && att.blob.present?

        rails_blob_path(att, disposition: "inline", only_path: true)
      rescue => e
        Rails.logger.warn "avatar_url build failed for Amigo##{amigo.id}: #{e.class}: #{e.message}"
        nil
      end

      # Stub for future authorization on destroy
      def authorize_amigo!; end
    end
  end
end


---
## app/models/amigo.rb

# models/amigo.rb

class Amigo < ApplicationRecord
  # === Associations ===
  has_one_attached :avatar
  has_one  :amigo_detail,    dependent: :destroy
  has_many :amigo_locations, dependent: :destroy
  has_many :lead_coordinator_for_events, class_name: 'Event', foreign_key: 'lead_coordinator_id'
  has_many :event_amigo_connectors
  has_many :events, through: :event_amigo_connectors

  # === Devise Modules ===
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable,
         :lockable, :timeoutable, :confirmable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtDenylist

  # Virtual attribute used for auth
  attr_accessor :login_attribute

  # === Validations ===
  validates :first_name, :last_name, presence: true, length: { maximum: 50 }

  validates :user_name,
            presence: true,
            uniqueness: { case_sensitive: false },
            length: { maximum: 50 },
            format: { with: /\A[a-zA-Z0-9_]+\z/ }

  validates :email,
            uniqueness: { case_sensitive: false },
            format: { with: URI::MailTo::EMAIL_REGEXP }

  validates :secondary_email,
            allow_blank: true,
            uniqueness: { case_sensitive: false },
            format: { with: URI::MailTo::EMAIL_REGEXP }

  validates :phone_1, uniqueness: true, allow_blank: true, format: { with: /\A\+\d{6,15}\z/ }
  validates :phone_2, uniqueness: true, allow_blank: true, format: { with: /\A\+\d{6,15}\z/ }

  validates :avatar, content_type: %w[image/png image/jpg image/jpeg image/svg+xml]

  # === Callbacks ===
  before_validation :normalize_identifiers
  after_commit :ensure_default_avatar, on: :create         # ← guarantee a default for new records
  after_commit :process_avatar, if: -> { avatar.attached? && !default_avatar_blob?(avatar.blob) }

  # === Authentication hook (login by username/email/phone) ===
  def self.find_for_database_authentication(warden_conditions)
    raw = warden_conditions[:login_attribute].to_s.strip
    return nil if raw.blank?

    login_down = raw.downcase
    phone_norm = normalize_phone(raw)

    where(
      "LOWER(user_name) = :login OR LOWER(email) = :login OR phone_1 = :phone OR phone_2 = :phone",
      login: login_down, phone: phone_norm
    ).first
  end

  # === Roles / helpers ===
  def admin?                    = (role == 'admin' || is_admin)
  def lead_coordinator_for?(e)  = event_amigo_connectors.exists?(event_id: e.id, role: 'lead_coordinator')
  def assistant_coordinator_for?(e) = event_amigo_connectors.exists?(event_id: e.id, role: 'assistant_coordinator')
  def can_remove_participant?(e) = lead_coordinator_for?(e) || assistant_coordinator_for?(e)
  def can_manage?(other)        = other && id == other.id
  def event_roles               = event_amigo_connectors.includes(:event).map { |c| { event_id: c.event_id, role: c.role } }

  # === Avatar helpers ===
  # Prefer controller helpers to build URLs; keep this for convenience if needed.
  def avatar_url
    Rails.application.routes.url_helpers.rails_blob_url(avatar, only_path: true) if avatar.attached?
  end

  # Allow selecting a seeded default by logical key (e.g., "avatar15", "default-amigo-avatar")
  # Falls back to old filesystem method if the catalog is unavailable.
  def attach_avatar_by_identifier(avatar_identifier)
    key = avatar_identifier.to_s.strip

    # 1) Preferred: use the catalog
    begin
      DefaultAvatars.sync! if DefaultAvatars.all.empty?
      if (blob = DefaultAvatars.find_by_key(key))
        avatar.attach(blob)
        return
      end
    rescue NameError
      # Catalog not loaded; fall through to filesystem method below.
    end

    # 2) Fallback: old file-based approach (dev convenience)
    path = Rails.root.join('lib/seeds/avatars/images').glob("#{key}.{png,jpg,jpeg,svg}").first
    if path && File.exist?(path)
      content_type = Marcel::MimeType.for(Pathname.new(path))
      avatar.attach(io: File.open(path), filename: File.basename(path), content_type: content_type)
    else
      errors.add(:avatar, "specified avatar does not exist: #{key}")
    end
  end

  # === JSON presentation ===
  def as_json(options = {})
    super(options).merge(
      phone_1: international_phone(phone_1),
      phone_2: international_phone(phone_2)
    )
  end

  private

  # Ensure each newly created Amigo has an avatar attached.
  def ensure_default_avatar
    return if avatar.attached?

    begin
      DefaultAvatars.sync! if DefaultAvatars.all.empty?
      blob = DefaultAvatars.find_by_key('default-amigo-avatar') || DefaultAvatars.random
      if blob
        avatar.attach(blob)
      else
        Rails.logger.warn "[Amigo##{id}] No default avatar blob available"
      end
    rescue NameError
      # Catalog not loaded (e.g., early dev). Leave without attaching; controllers can
      # serve a static fallback temporarily, or run the backfill task later.
      Rails.logger.warn "[Amigo##{id}] DefaultAvatars service unavailable; skipping default attach"
    end
  end

  # Skip reprocessing for catalog defaults; only process user-supplied uploads.
  def process_avatar
    processed = ImageProcessing::Vips
                  .source(avatar.download)
                  .resize_to_limit(300, 300)
                  .convert("png")
                  .call
    avatar.attach(io: File.open(processed.path), filename: "avatar.png", content_type: "image/png")
  rescue => e
    Rails.logger.error "Avatar processing failed for Amigo ##{id}: #{e.message}"
  end

  # Distinguish catalog blobs from user uploads.
  # Recommendation: in DefaultAvatars.sync!, set blob.metadata['default_catalog'] = true.
  def default_avatar_blob?(blob)
    return false unless blob
    !!blob.metadata['default_catalog'] ||
      blob.filename.to_s.start_with?('default-amigo-avatar') ||
      blob.metadata['source'] == 'default_catalog'
  end

  # --- Normalization helpers ---
  def normalize_identifiers
    self.user_name = user_name&.strip
    self.email     = email&.strip&.downcase
    self.phone_1   = self.class.normalize_phone(phone_1)
    self.phone_2   = self.class.normalize_phone(phone_2)
  end

  def self.normalize_phone(value)
    return nil if value.blank?
    Phonelib.parse(value).e164.presence
  end

  def international_phone(phone)
    phone.present? ? Phonelib.parse(phone).international : nil
  end

  # If you later relax identifiers, you can re-enable this:
  # def at_least_one_identifier_present
  #   if [user_name, email, phone_1, phone_2].all?(&:blank?)
  #     errors.add(:base, "Provide at least one of username, email, or phone.")
  #   end
  # end
end


---
## app/models/jwt_denylist.rb

# app/models/jwt_denylist.rb
class JwtDenylist < ApplicationRecord
  include Devise::JWT::RevocationStrategies::Denylist
  self.table_name = 'jwt_denylist'

  validates :jti, presence: true, uniqueness: true

  def self.jwt_revoked?(payload, amigo)
    Rails.logger.debug "JwtDenylist - Checking if JWT is revoked with payload: #{payload}"
    exists?(jti: payload['jti'])
  end
  
  def self.revoke_jwt(payload, amigo)
    Rails.logger.debug "JwtDenylist - Revoking JWT with payload: #{payload}"
    jti = payload['jti']
    exp = payload['exp']
  
    if jti && exp
      create!(jti: jti, exp: Time.at(exp))
    else
      Rails.logger.error "JwtDenylist - Missing jti or exp in payload: #{payload}"
      raise "Invalid payload: missing jti or exp"
    end
  end
end

---
## app/serializers/amigo_serializer.rb

# app/serializers/amigo_serializer.rb
class AmigoSerializer < ActiveModel::Serializer
  include Rails.application.routes.url_helpers

  attributes :id, :first_name, :last_name, :user_name, :email,
             :secondary_email, :phone_1, :phone_2, :avatar_url,
             :full_name, :formatted_created_at, :formatted_updated_at

  has_one  :amigo_detail
  has_many :amigo_locations

  def formatted_created_at
    object.created_at&.strftime("%Y-%m-%d %H:%M:%S")
  end

  def formatted_updated_at
    object.updated_at&.strftime("%Y-%m-%d %H:%M:%S")
  end

  def full_name
    [object.first_name, object.last_name].compact.join(' ').strip
  end

  def phone_1
    return nil if object.phone_1.blank?
    Phonelib.parse(object.phone_1).international
  end

  def phone_2
    return nil if object.phone_2.blank?
    Phonelib.parse(object.phone_2).international
  end

  # IMPORTANT: nil when no avatar, relative path when present
  def avatar_url
    return nil unless object.avatar.attached?
    rails_blob_path(object.avatar, only_path: true)
  end
end


---
## config/routes.rb

# config/routes.rb
Rails.application.routes.draw do
  # CORS preflight
  match '*path', via: :options, to: 'application#options_request'

  if Rails.env.development?
    mount LetterOpenerWeb::Engine, at: '/letter_opener'
  end

  scope '/api/v1', module: 'api/v1', defaults: { format: :json } do
    # CSRF handshake
    get    'csrf',          to: 'auth/csrf#show'

    # Signup still comes from Devise registrations
    devise_for :amigos,
      path: '',
      skip: [:sessions],                          # ⇣— don’t generate Devise’s own /login & /logout
      path_names: { sign_up: 'signup' },
      controllers: {
        registrations: 'auth/registrations',
        confirmations: 'auth/confirmations',
        passwords:     'auth/passwords',
        unlocks:       'auth/unlocks'
      }

    # Now manually re-declare all of the “session” routes you want:
      devise_scope :amigo do
        post   'login',         to: 'auth/sessions#create'
        delete 'logout',        to: 'auth/sessions#destroy'
        post   'signup',        to: 'auth/registrations#create'
        post   'refresh_token', to: 'auth/sessions#refresh'
        get    'verify_token',  to: 'auth/sessions#verify_token'
      end

    # Your application resources
    get    'me',            to: 'amigos#me'
    resources :amigos,      only: %i[index show create update destroy] do
      resource  :amigo_detail,    only: %i[show create update destroy]
      resources :amigo_locations, only: %i[index create show update destroy]
    end

    resources :events, except: %i[new edit] do
      resources :event_amigo_connectors, except: %i[new edit]
      resources :event_location_connectors, only: %i[index show create update destroy]
    end

    resources :event_locations, except: %i[new edit]
  end
end


---
## config/application.rb

# config/application.rb
require_relative 'boot'

# For API-only apps you can load just what you need, or keep rails/all.
# Keeping rails/all is fine; api_only will slim the middleware stack.
require 'rails/all'

Bundler.require(*Rails.groups)

module AmigosUniteApi
  class Application < Rails::Application
    config.load_defaults 7.1
    config.api_only = true

    # --- Cookies & Session (required for CSRF) ---
    config.middleware.use ActionDispatch::Cookies
    config.middleware.use Rack::Attack
    config.middleware.use(
      ActionDispatch::Session::CookieStore,
      key:       '_amigos_unite_session',
      same_site: :none,    # cross-site SPA <-> API
      secure:    true,     # you're on HTTPS (https://localhost)
      httponly:  true,
      path:      '/'
    )

    # You already call protect_from_forgery in your controllers.
    # No need to also set default_protect_from_forgery here.
    # (Remove this if you had it) -> config.action_controller.default_protect_from_forgery = true

    # --- CORS is configured in config/initializers/cors.rb ---

    # --- Rack::Attack: place early in the stack so it can short-circuit ---
    # If Rack::Runtime isn't present in api_only, insert before Rack::Head (or just use `use`).
    config.middleware.insert_before Rack::Runtime, Rack::Attack rescue config.middleware.use Rack::Attack

    # --- Devise / Warden ---
    # devise-jwt hooks into Warden automatically; you don't need to add Warden::JWTAuth::Middleware manually.
    # Remove this if you have it:
    # config.middleware.use Warden::JWTAuth::Middleware

    # --- Serializer / Jobs ---
    ActiveModelSerializers.config.adapter = :json_api
    config.active_job.queue_adapter = :async

    # --- Autoload/eager-load libraries under app/lib (where JsonWebToken lives) ---
    config.autoload_paths << Rails.root.join('app/lib')
    config.eager_load_paths << Rails.root.join('app/lib')
  end
end


---
## config/environments/development.rb

require "active_support/core_ext/integer/time"

Rails.application.configure do
  # -----------------------------------------------
  # URL and SSL Settings (Important for OAuth testing)
  # -----------------------------------------------
  host = 'localhost'
  port = 3001

  config.force_ssl = true # Required for OAuth callbacks and secure cookies
  config.action_mailer.default_url_options = { host:, port: }
  config.action_mailer.perform_caching = false
  Rails.application.routes.default_url_options = { host:, port: }
  config.default_url_options = { host: "http://#{host}:#{port}" }

  # -----------------------------------------------
  # Active Storage
  # -----------------------------------------------
  config.active_storage.service = :local

  # -----------------------------------------------
  # Code Loading & Caching
  # -----------------------------------------------
  config.cache_classes = false
  config.eager_load = false

  # -----------------------------------------------
  # Error Handling & Logging
  # -----------------------------------------------
  config.consider_all_requests_local = true
  config.server_timing = true
  config.log_level = :debug
  config.active_support.deprecation = :log
  config.active_support.disallowed_deprecation = :raise
  config.active_support.disallowed_deprecation_warnings = []
  config.action_dispatch.cookies_same_site_protection = :none

  config.active_record.migration_error = :page_load
  config.active_record.verbose_query_logs = true

  # Optional: Log format for cleaner logs
  config.log_formatter = ::Logger::Formatter.new

  # -----------------------------------------------
  # Caching Configuration
  # -----------------------------------------------
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.cache_store = :memory_store
    config.public_file_server.headers = {
      "Cache-Control" => "public, max-age=#{2.days.to_i}"
    }
  else
    config.action_controller.perform_caching = false
    config.cache_store = :null_store
  end

  # -----------------------------------------------
  # Action Mailer Delivery Settings
  # -----------------------------------------------
  config.action_mailer.raise_delivery_errors = false
  config.action_mailer.perform_caching = false
  config.action_mailer.delivery_method = :letter_opener_web
  config.action_mailer.perform_deliveries = true
  # To use letter_opener for viewing emails in the browser:
  # config.action_mailer.delivery_method = :letter_opener
  # config.action_mailer.perform_deliveries = true

  # -----------------------------------------------
  # Optional: Raise on missing translations
  # config.i18n.raise_on_missing_translations = true

  # -----------------------------------------------
  # Optional: Annotate views with file names
  # config.action_view.annotate_rendered_view_with_filenames = true

  # -----------------------------------------------
  # Optional: Allow Action Cable from any origin (if needed)
  # config.action_cable.disable_request_forgery_protection = true
end


---
## Gemfile.lock (devise/jwt/cors excerpts)



---
## Rake routes (auth endpoints)



---
## Devise mappings (rails runner)

